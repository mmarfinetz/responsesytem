# CD Pipeline for Plumbing AI Platform
name: Continuous Deployment

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      image_tag:
        description: 'Docker Image Tag'
        required: false
        default: 'latest'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: plumbing-ai/backend
  IMAGE_NAME_FRONTEND: plumbing-ai/frontend

jobs:
  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment:
      name: staging
      url: https://staging.plumbing-ai.yourdomain.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ vars.AWS_REGION }} --name ${{ vars.EKS_CLUSTER_NAME_STAGING }}

    - name: Set image tag
      id: image-tag
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi

    - name: Backup current deployment
      run: |
        kubectl get deployment backend -n plumbing-ai-staging -o yaml > backup-backend-staging.yaml
        kubectl get deployment frontend -n plumbing-ai-staging -o yaml > backup-frontend-staging.yaml

    - name: Deploy to staging namespace
      run: |
        # Create namespace if it doesn't exist
        kubectl create namespace plumbing-ai-staging --dry-run=client -o yaml | kubectl apply -f -
        
        # Apply configurations
        envsubst < k8s/namespace.yaml | sed 's/plumbing-ai/plumbing-ai-staging/g' | kubectl apply -f -
        envsubst < k8s/configmap.yaml | sed 's/plumbing-ai/plumbing-ai-staging/g' | kubectl apply -f -
        
        # Apply secrets (stored in GitHub Secrets)
        kubectl create secret generic plumbing-ai-secrets \
          --from-literal=DB_USER="${{ secrets.STAGING_DB_USER }}" \
          --from-literal=DB_PASSWORD="${{ secrets.STAGING_DB_PASSWORD }}" \
          --from-literal=REDIS_PASSWORD="${{ secrets.STAGING_REDIS_PASSWORD }}" \
          --from-literal=JWT_SECRET="${{ secrets.STAGING_JWT_SECRET }}" \
          --from-literal=WEBHOOK_SECRET="${{ secrets.STAGING_WEBHOOK_SECRET }}" \
          --from-literal=SESSION_SECRET="${{ secrets.STAGING_SESSION_SECRET }}" \
          --namespace=plumbing-ai-staging \
          --dry-run=client -o yaml | kubectl apply -f -
        
        kubectl create secret generic external-api-secrets \
          --from-literal=ANTHROPIC_API_KEY="${{ secrets.ANTHROPIC_API_KEY }}" \
          --from-literal=GOOGLE_OAUTH_CLIENT_ID="${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}" \
          --from-literal=GOOGLE_OAUTH_CLIENT_SECRET="${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET }}" \
          --from-literal=GOOGLE_OAUTH_REDIRECT_URI="${{ secrets.STAGING_GOOGLE_OAUTH_REDIRECT_URI }}" \
          --namespace=plumbing-ai-staging \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Deploy database and redis
        envsubst < k8s/postgres.yaml | sed 's/plumbing-ai/plumbing-ai-staging/g' | kubectl apply -f -
        envsubst < k8s/redis.yaml | sed 's/plumbing-ai/plumbing-ai-staging/g' | kubectl apply -f -
        
        # Wait for database to be ready
        kubectl wait --for=condition=ready pod -l component=postgres -n plumbing-ai-staging --timeout=300s
        kubectl wait --for=condition=ready pod -l component=redis -n plumbing-ai-staging --timeout=300s

    - name: Run database migrations
      run: |
        kubectl run migration-job-$(date +%s) \
          --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ steps.image-tag.outputs.tag }} \
          --restart=Never \
          --namespace=plumbing-ai-staging \
          --env="NODE_ENV=staging" \
          --env="DB_HOST=postgres-service" \
          --env="DB_USER=${{ secrets.STAGING_DB_USER }}" \
          --env="DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" \
          --command -- npm run db:migrate
        
        # Wait for migration to complete
        kubectl wait --for=condition=complete job/migration-job-* -n plumbing-ai-staging --timeout=300s
        
        # Clean up migration job
        kubectl delete job migration-job-* -n plumbing-ai-staging

    - name: Deploy application services
      run: |
        # Update image tags in deployment files
        sed -i "s|plumbing-ai/backend:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ steps.image-tag.outputs.tag }}|g" k8s/backend.yaml
        sed -i "s|plumbing-ai/frontend:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ steps.image-tag.outputs.tag }}|g" k8s/frontend.yaml
        
        # Deploy backend and frontend
        envsubst < k8s/backend.yaml | sed 's/plumbing-ai/plumbing-ai-staging/g' | kubectl apply -f -
        envsubst < k8s/frontend.yaml | sed 's/plumbing-ai/plumbing-ai-staging/g' | kubectl apply -f -
        
        # Deploy ingress
        envsubst < k8s/ingress.yaml | sed 's/plumbing-ai/plumbing-ai-staging/g' | sed 's/yourdomain.com/staging.yourdomain.com/g' | kubectl apply -f -

    - name: Wait for deployment to be ready
      run: |
        kubectl rollout status deployment/backend -n plumbing-ai-staging --timeout=600s
        kubectl rollout status deployment/frontend -n plumbing-ai-staging --timeout=600s

    - name: Run health checks
      run: |
        # Wait for services to be healthy
        sleep 30
        
        # Check backend health
        kubectl run health-check-backend-$(date +%s) \
          --image=curlimages/curl \
          --restart=Never \
          --namespace=plumbing-ai-staging \
          --rm -i --tty \
          --command -- curl -f http://backend-service:3000/api/health
        
        # Check frontend health
        kubectl run health-check-frontend-$(date +%s) \
          --image=curlimages/curl \
          --restart=Never \
          --namespace=plumbing-ai-staging \
          --rm -i --tty \
          --command -- curl -f http://frontend-service:8080/health

    - name: Run smoke tests
      run: |
        # Create test job
        kubectl create job smoke-test-$(date +%s) \
          --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ steps.image-tag.outputs.tag }} \
          --namespace=plumbing-ai-staging \
          -- npm run test:smoke
        
        # Wait for smoke tests to complete
        kubectl wait --for=condition=complete job/smoke-test-* -n plumbing-ai-staging --timeout=300s

    - name: Notify staging deployment success
      uses: 8398a7/action-slack@v3
      with:
        status: success
        text: 'Staging deployment succeeded for Plumbing AI Platform'
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
      if: success()

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment:
      name: production
      url: https://plumbing-ai.yourdomain.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ vars.AWS_REGION }} --name ${{ vars.EKS_CLUSTER_NAME_PRODUCTION }}

    - name: Set image tag
      id: image-tag
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi

    - name: Create backup
      run: |
        # Backup current deployment
        kubectl get all -n plumbing-ai -o yaml > backup-production-$(date +%Y%m%d-%H%M%S).yaml
        
        # Upload backup to S3
        aws s3 cp backup-production-$(date +%Y%m%d-%H%M%S).yaml s3://${{ vars.BACKUP_BUCKET }}/deployments/

    - name: Blue-Green Deployment Setup
      run: |
        # Create green namespace for new deployment
        kubectl create namespace plumbing-ai-green --dry-run=client -o yaml | kubectl apply -f -
        
        # Copy secrets to green namespace
        kubectl get secret plumbing-ai-secrets -n plumbing-ai -o yaml | sed 's/namespace: plumbing-ai/namespace: plumbing-ai-green/' | kubectl apply -f -
        kubectl get secret external-api-secrets -n plumbing-ai -o yaml | sed 's/namespace: plumbing-ai/namespace: plumbing-ai-green/' | kubectl apply -f -

    - name: Deploy to Green Environment
      run: |
        # Deploy to green namespace
        sed -i "s|plumbing-ai/backend:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ steps.image-tag.outputs.tag }}|g" k8s/backend.yaml
        sed -i "s|plumbing-ai/frontend:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ steps.image-tag.outputs.tag }}|g" k8s/frontend.yaml
        
        envsubst < k8s/configmap.yaml | sed 's/plumbing-ai/plumbing-ai-green/g' | kubectl apply -f -
        envsubst < k8s/backend.yaml | sed 's/plumbing-ai/plumbing-ai-green/g' | kubectl apply -f -
        envsubst < k8s/frontend.yaml | sed 's/plumbing-ai/plumbing-ai-green/g' | kubectl apply -f -

    - name: Wait for Green Deployment
      run: |
        kubectl rollout status deployment/backend -n plumbing-ai-green --timeout=600s
        kubectl rollout status deployment/frontend -n plumbing-ai-green --timeout=600s

    - name: Run Production Health Checks
      run: |
        # Comprehensive health checks
        sleep 60
        
        # Check all services
        kubectl run health-check-$(date +%s) \
          --image=curlimages/curl \
          --restart=Never \
          --namespace=plumbing-ai-green \
          --rm -i --tty \
          --command -- sh -c "
            curl -f http://backend-service:3000/api/health &&
            curl -f http://frontend-service:8080/health &&
            curl -f http://backend-service:3000/api/health/ready"

    - name: Run Load Tests
      run: |
        # Run load tests against green environment
        kubectl create job load-test-$(date +%s) \
          --image=loadimpact/k6 \
          --namespace=plumbing-ai-green \
          -- k6 run --vus 50 --duration 2m /scripts/load-test.js
        
        kubectl wait --for=condition=complete job/load-test-* -n plumbing-ai-green --timeout=300s

    - name: Switch Traffic (Blue-Green)
      run: |
        # Update ingress to point to green deployment
        kubectl patch service backend-service -n plumbing-ai -p '{"spec":{"selector":{"app":"plumbing-ai-platform","component":"backend","deployment":"green"}}}'
        kubectl patch service frontend-service -n plumbing-ai -p '{"spec":{"selector":{"app":"plumbing-ai-platform","component":"frontend","deployment":"green"}}}'
        
        # Wait and verify traffic switch
        sleep 30
        
        # Test the switch
        kubectl run traffic-test-$(date +%s) \
          --image=curlimages/curl \
          --restart=Never \
          --namespace=plumbing-ai \
          --rm -i --tty \
          --command -- curl -f http://backend-service:3000/api/health

    - name: Monitor Post-Deployment
      run: |
        # Monitor for 5 minutes post-deployment
        echo "Monitoring deployment for 5 minutes..."
        for i in {1..10}; do
          kubectl get pods -n plumbing-ai-green
          kubectl top pods -n plumbing-ai-green
          sleep 30
        done

    - name: Cleanup Blue Environment
      run: |
        # Keep blue environment for 1 hour for potential rollback
        echo "Blue environment cleanup scheduled for 1 hour"
        kubectl create job cleanup-blue-$(date +%s) \
          --image=bitnami/kubectl \
          --namespace=plumbing-ai \
          --schedule="0 * * * *" \
          -- kubectl delete namespace plumbing-ai-blue --ignore-not-found

    - name: Update Production Labels
      run: |
        # Label green as current production
        kubectl label namespace plumbing-ai-green environment=production --overwrite
        kubectl label namespace plumbing-ai environment=blue --overwrite

    - name: Notify production deployment success
      uses: 8398a7/action-slack@v3
      with:
        status: success
        text: 'Production deployment succeeded for Plumbing AI Platform'
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
      if: success()

  # Rollback Job
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure()
    needs: [deploy-production]

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ vars.AWS_REGION }} --name ${{ vars.EKS_CLUSTER_NAME_PRODUCTION }}

    - name: Rollback to Previous Version
      run: |
        # Switch traffic back to blue (previous version)
        kubectl patch service backend-service -n plumbing-ai -p '{"spec":{"selector":{"app":"plumbing-ai-platform","component":"backend","deployment":"blue"}}}'
        kubectl patch service frontend-service -n plumbing-ai -p '{"spec":{"selector":{"app":"plumbing-ai-platform","component":"frontend","deployment":"blue"}}}'
        
        # Verify rollback
        kubectl run rollback-test-$(date +%s) \
          --image=curlimages/curl \
          --restart=Never \
          --namespace=plumbing-ai \
          --rm -i --tty \
          --command -- curl -f http://backend-service:3000/api/health

    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: 'Production deployment failed, rolled back to previous version'
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}